"""
__main__.py
-----------

decu console commands.

"""

import os
import re
import sys
import decu
from importlib import import_module


def _extract_script_class(module):
    """Return the subclass of decu.Script found in module."""
    for obj in module.__dict__.values():
        if isinstance(obj, type) and decu.Script in obj.__bases__:
            return obj


def exec_script(files):
    """Execute the main function inside each file."""
    import logging

    for file in files:
        module_path, module_file = os.path.split(file)
        module_name, _ = os.path.splitext(module_file)
        project_dir, _ = os.path.split(module_path)
        sys.path.append(os.path.abspath(module_path))
        try:
            module = import_module(module_name)
        except ImportError:
            return 'File {} not found.'.format(module_file)

        script = _extract_script_class(module)()
        script.main()
        logger = logging.getLogger()
        for handler in logger.handlers[:]:
            handler.flush()
            logger.removeHandler(handler)

    return 0


def init(directory):
    """Initialize the directory for a decu project."""
    cfg = decu.config['Script']
    mkdir = lambda name: os.makedirs(os.path.join(directory, name), exist_ok=True)
    for dir_name in [key for key in cfg if key.endswith('_dir')]:
        mkdir(cfg[dir_name])
    print('Initialized empty decu project directory in {}'.format(directory))
    return 0


def _parse_inspect_opts(opts):
    """Parse the remainder of the options given to decu inspect."""
    if len(opts) % 2 != 0:
        sys.exit('Additional options need to come in pairs.')
    return {name.strip('-'): path for name, path in
            [opts[i:i + 2] for i in range(0, len(opts), 2)]}


def _get_script_name(files):
    """Extract the script name that generated the file."""
    file = files[0]
    _, filename = os.path.split(file)
    search = re.sub(r'\$\{.*?\}', '(.*?)',
                    re.sub(r'\.', r'\.', decu.config['Script']['result_file']))
    search = r'^{}$'.format(search)

    match = re.match(search, filename)

    if match is None:
        raise decu.DecuException('module not found')
    else:
        return re.match(search, filename).group(2)


def _make_py_script(script, files, command, kwargs):
    """Build the script that will be run within iPython."""
    scr_cfg = decu.config['Script']
    ins_cfg = decu.config['inspect']

    cmd = ins_cfg['py_cmd_imports']
    if script is not None:
        sys.path.append(scr_cfg['scripts_dir'])
        module = import_module(script)
        class_name = _extract_script_class(module).__name__
        cmd += ins_cfg.subs('py_cmd_script',
                            dir=scr_cfg['scripts_dir'].strip('/'),
                            script=script,
                            cls=class_name)

    cmd_noshow = ins_cfg.subs('py_cmd_noshow', files=files)

    cmd_full = '\n'.join([cmd, cmd_noshow] +
                         ['{} = np.loadtxt("{}")'.format(name, path)
                          for name, path in kwargs.items()])

    cmd_show = cmd + '\n' + \
        '\n'.join(ins_cfg.subs('noshow_replace', var=name)
                  for name in ['result'] + list(kwargs.keys()))
    cmd_show = '>>> ' + re.sub(r'\n(.)', r'\n>>> \1', cmd_show)

    if command is not None:
        cmd_full += '\n' + command
        cmd_show += '\n>>> ' + command

    return cmd_full, cmd_show


def inspect(files, command=None, **kwargs):
    """Load files into ipython.

    All files loaded must have been generated by the same script.

    """
    from subprocess import call
    from tempfile import NamedTemporaryFile

    for file in files:
        if not os.path.exists(file):
            return 'File {} not found.'.format(file)

    try:
        script_name = _get_script_name(files)
        script_fullname = os.path.join(decu.config['Script']['scripts_dir'],
                                       script_name)
        script_fullname += '.py'
        if not os.path.exists(script_fullname):
            return 'File {} not found.'.format(script_fullname)
        cmd, cmd_show = _make_py_script(script_name, files, command, kwargs)

    except decu.DecuException:
        cmd, cmd_show = _make_py_script(None, files, command, kwargs)

    print(cmd_show)

    cli_cmd_opts = ['--no-banner']
    if command is None:
        cli_cmd_opts.append('-i')
    with NamedTemporaryFile('w+') as tmp:
        tmp.write(cmd)
        tmp.read()
        cli_cmd = ['ipython', tmp.name] + cli_cmd_opts
        call(cli_cmd)

    return 0


def setup_parser():
    import argparse
    parser = argparse.ArgumentParser(description='Experimental computation '
                                     'utilities.')
    subparsers = parser.add_subparsers(help='command', dest='command')

    parser_init = subparsers.add_parser('init', help='initialize a decu '
                                        'project under this directory')

    parser_exec = subparsers.add_parser('exec', help='run a script with decu')
    parser_exec.add_argument('files', nargs='+', help='the script(s) '
                             'to be run')

    parser_inspect = subparsers.add_parser('inspect', help='inspect results')
    parser_inspect.add_argument('files', nargs='+', help='files to be'
                                'loaded as result')
    parser_inspect.add_argument('-c', dest='inspect_command',
                                help='Execute the given command string')
    parser_inspect.add_argument('opts', nargs=argparse.REMAINDER,
                                help='pairs of name and file paths to read '
                                'as additional variables')

    return parser


def main():
    """Execute the script passed as command line argument."""
    parser = setup_parser()
    args = parser.parse_args()

    if args.command is None:
        parser.print_help()
        sys.exit(0)

    elif args.command == 'exec':
        sys.exit(exec_script(args.files))

    elif args.command == 'init':
        sys.exit(init(os.getcwd()))

    elif args.command == 'inspect':
        sys.exit(inspect(args.files, command=args.inspect_command,
                         **_parse_inspect_opts(args.opts)))


if __name__ == "__main__":
    main()
